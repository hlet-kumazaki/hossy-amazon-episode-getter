name: Fetch & Update (AmazonMusic -> WP)

on:
  workflow_dispatch:
    inputs:
      post_id:
        description: "Target post_id (optional)"
        required: false
        type: string
  repository_dispatch:
    types: [run-fetch-update, cron-trigger]
  # schedule は GitHub 側の遅延回避のため使用しない（ロリポップの cron で 06:03 JST に外部発火）
  #schedule:
  #  # 毎週金曜 06:03 JST（= 木曜 21:03 UTC）
  #  - cron: "3 21 * * 4"

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install deps
        run: |
          npm ci || npm i
          npx playwright install --with-deps

      - name: Fetch URL & Update WP
        id: runit
        env:
          CHANNEL_URL: ${{ vars.CHANNEL_URL }}   # repo Variables で管理（現状 cjs 側では未使用だが保持）
          WP_USER: ${{ secrets.WP_USER }}
          WP_PASS: ${{ secrets.WP_PASS }}
          FIELD_KEY: ${{ vars.FIELD_KEY }}
          ENDPOINTS: ${{ vars.ENDPOINTS }}
          POST_ID: ${{ inputs.post_id }}         # 手動Run時のみ任意指定可
          # 全てalready_has_value時のメール通知フラグ（'true' または 'false'）
          # 直接値を変更する場合は 'true' または 'false' を指定
          NOTIFY_ON_SKIP_ALL: ${{ vars.NOTIFY_ON_SKIP_ALL || 'true' }}
        run: |
          set -euo pipefail
          OUT=$(node amz_first_card_and_update_wp.cjs)
          # 保存用は整形したまま
          echo "$OUT" > result.json
          # GITHUB_OUTPUT には 1 行 JSON を渡す
          OUT_ONE_LINE=$(echo "$OUT" | jq -c . || echo '{}')
          echo "json=$OUT_ONE_LINE" >> "$GITHUB_OUTPUT"

      - name: Summary
        run: |
          echo "### Result JSON" >> $GITHUB_STEP_SUMMARY
          echo '```json' >> $GITHUB_STEP_SUMMARY
          if [ -f result.json ]; then cat result.json >> $GITHUB_STEP_SUMMARY; else echo '{}' >> $GITHUB_STEP_SUMMARY; fi
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Prepare email content
        if: always()
        id: emailprep
        run: |
          set -euo pipefail

          # Read result.json (fallback to {})
          if [ -f result.json ]; then RES=$(cat result.json); else RES="{}"; fi
          if ! echo "$RES" | jq . >/dev/null 2>&1; then RES="{}"; fi
          SKIPPED_ALL=$(echo "$RES" | jq -r '.skipped_all // false')
          NOTIFY_ON_SKIP_ALL=$(echo "$RES" | jq -r '.notify_on_skip_all // true')
          WARN_NO_NEW=$(echo "$RES" | jq -r '.warn_no_new_episode // false')

          {
            echo "### Emailprep RES (debug)" >> "$GITHUB_STEP_SUMMARY"
            echo '```json' >> "$GITHUB_STEP_SUMMARY"
            echo "$RES" >> "$GITHUB_STEP_SUMMARY"
            echo '```' >> "$GITHUB_STEP_SUMMARY"
          } || true

          # 全てスキップされた場合の簡潔なメール本文
          if [ "$SKIPPED_ALL" = "true" ] && [ "$NOTIFY_ON_SKIP_ALL" = "true" ]; then
            TARGET_TITLE=$(echo "$RES" | jq -r '.target_title // "(title unknown)"')
            JST_NOW=$(TZ=Asia/Tokyo date '+%Y / %m / %d %H:%M')
            MESSAGE=$(echo "$RES" | jq -r '.message // "全てのプラットフォームで既にURLが登録済みのため、処理をスキップしました。"')
            
            SUBJECT="エピソードURL更新通知 — 更新済み / ${TARGET_TITLE}"
            
            {
              echo "エピソードURL取り込み処理をスキップしました。"
              echo
              echo "実行日時：${JST_NOW}"
              echo "対象ページ：${TARGET_TITLE}"
              echo
              echo "${MESSAGE}"
            } > email_body.txt
          elif [ "$SKIPPED_ALL" = "true" ] && [ "$NOTIFY_ON_SKIP_ALL" = "false" ]; then
            # スキップされたが通知しない場合は空のメール本文とsubjectを作成（メール送信をスキップするため）
            echo "" > email_body.txt
            SUBJECT=""
          else
            STATUS_TXT=$( 
              echo "$RES" | jq -r '
                # プラットフォーム配列の安全な取得
                def platforms: (.platforms // []);
    
                # 更新成功した件数
                def okcount: ([platforms[]? | select(.updated==true)] | length);
    
                # 総プラットフォーム数
                def total: (platforms | length // 0);
    
                # スキップ理由を取得（他の箇所と揃える）
                def reason($p): ($p.skipped_reason // $p.reason // ($p.meta // {}).reason // ($p.meta // {}).skipped_reason);
    
                # 「スキップ扱い」に含める理由（既存値あり / 整合性NG / 新着なし など）
                def is_skipped($p):
                  (reason($p) // "") as $r
                  | ($r == "already_has_value"
                     or $r == "coherence_mismatch"
                     or $r == "no_new_episode");
    
                # エラー扱い（updated=false かつ スキップ理由ではない）
                def errcount:
                  ([platforms[]? | select(.updated != true and (is_skipped(.) | not))] | length);
    
                if (total == 0) then
                  "不明"
                elif (okcount > 0) then
                  if (okcount == total) then "全て成功" else "一部成功" end
                elif (errcount > 0) then
                  "全て失敗"
                else
                  # updated=0 かつ errcount=0 → 全てスキップ
                  "全てスキップ"
                end
              '
            )

            TARGET_TITLE=$(echo "$RES" | jq -r '.target_title // "(title unknown)"')
            TARGET_URL=$(echo   "$RES" | jq -r '.target_url   // "(url unknown)"')
            SUBJECT="エピソードURL更新通知 — ${STATUS_TXT} / ${TARGET_TITLE}"

            # JST current timestamp for "実施日時：YYYY / mm / dd H:i"
            JST_NOW=$(TZ=Asia/Tokyo date '+%Y / %m / %d %H:%M')

            # Build platform sections in fixed order with human-readable labels + 取得ログ
            PLAT_SECTIONS=$( 
              echo "$RES" | jq -r '
                def reason($p): ($p.skipped_reason // $p.reason // ($p.meta // {}).reason // ($p.meta // {}).skipped_reason);
                def status($p):
                  if ($p.updated == true) then "成功"
                  elif (reason($p)) then "スキップ"
                  elif ($p.updated == false) then "失敗"
                  else "不明" end;
                def pick($name; $label):
                  ( first(.platforms[]? | select(.name==$name)) // {} ) as $p
                  | {
                      label:  $label,
                      sym: (
                        if    ($p.coherence.matched == null)  then "--"
                        elif  ($p.coherence.matched == true)  then "✅"
                        elif  ($p.coherence.matched == false) then "❌"
                        else "--"   # fallback for unexpected types
                        end
                      ),
                      url:    ( $p.episode_url // "" ),
                      reason: ( reason($p) ),
                      status: ( status($p) )
                    };
                [
                  pick("amazon_music"; "Amazon Music"),
                  pick("youtube";      "YouTube Music"),
                  pick("itunes";       "Apple Podcasts"),
                  pick("spotify";      "Spotify")
                ]
                | .[]
                | "◯\(.label)\n- 整合性チェック：\(.sym)\n- 更新結果：\(.status)\n- URL：\(.url // "（未取得）")\n- 取得ログ：\(.reason // "—")\n"
              '
            )

            {
              if [ "$WARN_NO_NEW" = "true" ]; then
                echo "※※※新しいエピソードが公開されていない可能性があります※※※"
                echo
              fi
              echo "エピソードURL取り込みを実行しました。"
              echo
              echo "実行日時：${JST_NOW}"
              echo "対象ページ：${TARGET_TITLE}"
              echo "${TARGET_URL}"
              echo
              printf "%s\n" "$PLAT_SECTIONS"
            } > email_body.txt
          fi

          {
            echo "subject<<EOF"
            printf '%s\n' "$SUBJECT"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          {
            echo "body<<EOF"
            cat email_body.txt
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          # NOTIFY_ON_SKIP_ALLを直接GITHUB_OUTPUTに書き込む（スキップされたが通知しない場合はfalse）
          if [ "$SKIPPED_ALL" = "true" ] && [ "$NOTIFY_ON_SKIP_ALL" = "false" ]; then
            echo "should_send_email=false" >> "$GITHUB_OUTPUT"
          else
            echo "should_send_email=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Send notification email
        if: always() && steps.emailprep.outputs.should_send_email == 'true'
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_HOST }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: ${{ steps.emailprep.outputs.subject }}
          #to: y.kumazaki@hlet.jp, hossy@hossy.org, rika@moontracks.net
          to: y.kumazaki@hlet.jp
          from: ${{ secrets.MAIL_FROM }}
          body: ${{ steps.emailprep.outputs.body }}

      - uses: actions/upload-artifact@v4
        with:
          name: result
          path: result.json

    concurrency:
      group: amz-wp-update
      cancel-in-progress: true